输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1, 2, 3, 4, 5是某栈的压入顺序，序列4，5, 3, 2, 1是该压栈序列对应的一个弹出序列，但4, 3, 5, 1, 2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

算法：

1.首先创建一个辅助栈
2.将入栈序列元素一次压入栈中
3.当压入一个元素以后，将其从栈中拿出判断是否和出栈序列的第一个元素相等。如果相等则将该元素从栈中弹出，然后出栈序列向后走，继续从栈中拿出元素判断。如果辅助栈为空，那么继续压入新元素
4.如果拿出来的元素不等于出栈序列对应的元素，那么继续压入下一个炸
5.最后出栈所有的序列都经过上面的步骤了以后。如果辅助栈为空，那么出栈序列和法，否则不合法

class Solution {
private:
	stack<int> s;
public:
	bool IsPopOrder(vector<int> pushV, vector<int> popV) {
		int n = pushV.size();
		vector<int>::iterator it = popV.begin();
		for (int i = 0; i < n; i++)
		{
			s.push(pushV[i]);
			while (!s.empty() && s.top() == *it)//不等于则压入
			{
				s.pop();
				it++;
			}
		}
		return s.empty();
	}
};