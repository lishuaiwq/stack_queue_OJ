给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{ 2, 3, 4, 2, 6, 2, 5, 1 }及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{ 4, 4, 6, 6, 6, 5 }； 针对数组{ 2, 3, 4, 2, 6, 2, 5, 1 }的滑动窗口有以下6个：{ [2, 3, 4], 2, 6, 2, 5, 1 }，{ 2, [3, 4, 2], 6, 2, 5, 1 }，{ 2, 3, [4, 2, 6], 2, 5, 1 }，{ 2, 3, 4, [2, 6, 2], 5, 1 }，{ 2, 3, 4, 2, [6, 2, 5], 1 }，{ 2, 3, 4, 2, 6, [2, 5, 1] }。

算法：普通算法使用两个for循环外层控制总体遍历,内存控制滑动窗口的大小，然后在内存循环中找最大值

采取双端队列：
即将数组中的内容尾插值队列（注意队列里面保存的是数组中元素对应的下标，方便删除操作），当在次插入的话和队尾的元素比较如果大于队尾元素的话，说明当前队尾元素已经没什么作用了，就可以出队列了，如果队列中还有元素，则继续比较。

如果队首的元素的位置超出了滑动窗口则也需要弹出

如果当前队列有效则找最大值

class Solution {
public:
	vector<int> maxInWindows(const vector<int>& num, unsigned int size)
	{
		vector<int> v;
		deque<int> d;
		if (size<1)
			return v;
		for (unsigned int i = 0; i < num.size(); i++)
		{
			while (!d.empty() && num[d.back()] <= num[i])
			{
				d.pop_back();//弹出队头元素	
			}
			while (!d.empty() && i - d.front() + 1>size)
			{
				d.pop_front();
			}
			d.push_back(i);//将当前元素的下标插入
			if (!d.empty() && i + 1 >= size)
			{
				v.push_back(num[d.front()]);
			}
		}
		return v;
	}
};